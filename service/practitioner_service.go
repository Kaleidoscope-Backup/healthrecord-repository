package service

import (
	"errors"

	"github.com/globalsign/mgo/bson"
	"github.com/karte/healthrecord-repository/model"
	"github.com/karte/mongo-lib/mserver"
	logging "github.com/op/go-logging"
)

// PractitionerService type
// Include:
//
//	-> logger
//	-> DataAccessLayer (provides methods to interact with Mongo DB)
type PractitionerService struct {
	dal mserver.DataAccessLayer
	log *logging.Logger
}

// NewPractitionerService creates a new Practitioner service that has all calls to the database, queries and mutations via the Data Access Layer
func NewPractitionerService(dal mserver.DataAccessLayer, log *logging.Logger) *PractitionerService {
	return &PractitionerService{dal: dal, log: log}
}

/*==========================================================================================
Query Operations
==========================================================================================*/

// FindByEmail ...
func (u *PractitionerService) FindByEmail(emailID string) (*[]*model.Practitioner, error) {
	if emailID == "" {
		return nil, errors.New("Missing required parameter email id parameter")
	}

	var params map[string]string
	params = map[string]string{}

	params["email"] = emailID

	//find the matching consumer Record (if any) from Mongo
	relArr, err := FindRecords(&params, &model.Consumer{}, u.dal)
	if err != nil {
		return nil, err
	}

	var practitionerArr []*model.Practitioner
	for _, relr := range relArr {
		var practitioner *model.Practitioner
		bsonBytes, _ := bson.Marshal(relr)
		bson.Unmarshal(bsonBytes, &practitioner)
		practitionerArr = append(practitionerArr, practitioner)
	}

	return &practitionerArr, nil
}

// FindByID ...
func (u *PractitionerService) FindByID(id string) (*model.Practitioner, error) {
	if id == "" {
		return nil, errors.New("Missing parameter id")
	}

	//find the matching Practitioner (if any) from Mongo
	p, err := u.dal.Get(id, &model.Practitioner{})
	if err != nil {
		return nil, err
	}

	//we need to unmarshal the result from type bson.M{} to model.Practitioner
	//Convert BSON (byte) to JSON Fields
	var practitioner *model.Practitioner
	bsonBytes, _ := bson.Marshal(p)
	bson.Unmarshal(bsonBytes, &practitioner)

	return practitioner, nil
}

// FindByName will find the Practitioner by the name provided
func (u *PractitionerService) FindByName(firstName string, lastName string) ([]model.Practitioner, error) {
	// practitioner := &model.Practitioner{}
	// practitioner.Id = "123456"
	// practitioner.Name = name
	// practitioner.Qualification = "Doctor"
	// practitioner.Speciality = "Cardiovascular"

	practitioners := []model.Practitioner{}

	return practitioners, nil
}

/*==========================================================================================
Mutation Operations
==========================================================================================*/

// UpdatePractitioner ...
func (u *PractitionerService) UpdatePractitioner(practitioner *model.Practitioner) (*model.Practitioner, error) {

	if practitioner != nil {
		_, err := u.dal.Put(practitioner.Id, practitioner)
		if err != nil {
			return nil, err
		}

		return practitioner, nil
	}

	return nil, nil
}

// CreatePractitioner will create a new practitioner in Mongo using the Data Access Layer
func (u *PractitionerService) CreatePractitioner(practitioner *model.Practitioner) (*model.Practitioner, error) {

	//validate required fields (besides Id which is generated by Post)
	if practitioner.FirstName == "" ||
		practitioner.LastName == "" ||
		practitioner.Email == "" ||
		practitioner.Speciality == "" ||
		practitioner.Qualification == "" ||
		practitioner.Organization == "" {

		return nil, errors.New("Missing a required field: aborting before saving to the DB")
	}

	_, err := u.dal.Post(practitioner)
	if err != nil {
		return nil, err
	}

	return practitioner, nil
}
